# MSmetaProfiler

This repository hosts Metabolome Annotation Workflow from LCMS-2 spectra in mzML format. The workflow has been developed using LCMS-2 dataset from a marine diatom _Skeletonema costatum_.

## Usage of R-Workflow
### Installation
Install latest R version (>=R 4.1). 
Create a conda env and install following libraries. Note: R 4.1 can also be installed in the same conda env. 
```
conda update conda
conda create --name myenv python=3.10.0 R=4.1.2
conda activate myenv
conda install -c bioconda bioconductor-camera
conda install -c bioconda bioconductor-spectra
conda install -c bioconda bioconductor-msbackendmgf
conda install -c bioconda bioconductor-mscoreutils
conda install -c r r-readr
conda install -c r r-dplyr
conda install -c r r-stringr
conda install -c r r-xml2
conda install -c r r-remotes
R
> remotes::install_github("rformassspectrometry/MsBackendHmdb")
> remotes::install_github("rformassspectrometry/MsBackendMsp")

```

### Input files and Directories

An input directory (input_dir) should have the following files for the Workflow to run.
1. All LCMS-2 spectra .mzML files
2. SIRIUS installation zip folder
3. MetFrag jar file which can be downloaded from <https://github.com/ipb-halle/MetFragRelaunched/releases>. You can also download the MetFrag version shared in this repository.
4. MetFrag_AdductTypes.csv can be downloaded from <https://github.com/schymane/ReSOLUTION/blob/master/inst/extdata/MetFrag_AdductTypes.csv>
5. (optional) /QC folder containing all (MS1) QC .mzML files 
6. (optional) Suspect List in csv format (important column - "SMILES")
7. (optional) Sl_metfrag.txt (This file contains the InChIKeys for all SMILES in suspect list is generated by the python function - slist_metfrag) for MetFrag
8. (optional) ScostSLS/ (This folder is a fragmentation folder for each SMILES present in the suspect list and is generated by the python function - slist_SIRIUS) for SIRIUS 

### Tutorial of Workflow

1. Load Dependencies:

```library(Spectra)
library(MsBackendMgf)
library(MsBackendHmdb)
library(MsCoreUtils)
library(MsBackendMsp)
library(readr)
library(dplyr)
library(rvest)
library(stringr)
library(xml2)
```

2. Define input directory. Make sure that you have input LCMS-2 spectra files in .mzML format in the input directory.

```
input_dir <- "usr/s_cost/"
```
3. Load the open spectral libraries. This function will take a lot of computational resources. However, to skip this function, you can download the current versions of the these databases from <write the link here and ask where can you provide datasets>. The databases are stored in the same input directory and in .rda format, as a R object.

```
# db argument can take "all", "gnps", "mbank" and "hmdb". Default (and recommended) is "all".
download_specDB(input_dir, db = "all")
```
4. Load the database .rda objects to the current R session.
  
```
load(file = paste(input_dir,"gnps.rda", sep = ""))
load(file = paste(input_dir,"hmdb.rda", sep = ""))
load(file = paste(input_dir,"mbank.rda", sep = ""))
```
5. Create a table that lists all the input .mzML files and the result directories with the same name as the input file. The function ```ms2_rfilename``` gives an id to the file as well.
  
```
input_table <- data.frame(ms2_rfilename(input_dir))
```

6. (optional) If you are using QC files, follow these steps as well. QC samples are used to normalize the signals across all samples. So, generally, QC files contain all the signals from MS1 files with higher m/z resolution. These files also contain the isotopic peaks and can be usd for formula identification in SIRIUS. 
    1. If you have files with positive and negative modes in one file, follow the first section of code. It takes all files in the QC folder with a certain pattern (choose a pattern from your file names, could be even .mzML as this is the format of all files in QC folder) and divides the pos and neg modes from each file and generate different mode .mzML files (01pos.mzmL and 01neg.mzML). These files are read by "CAMERA", which is loaded within the function. the outputs are several csv files with CAMERA results, which are merged into one csv file for each mode.
    2. If you have files with positive and negative modes in separate files, follow the second section of code. It takes one file in the QC folder with either pos or neg mode. These files are read by "CAMERA", which is loaded within the function.
               
```
# first section
cam_funcMode(path = paste(input_dir, "QC", sep =""), pattern = "common")
merge_qc(path = paste(input_dir, "QC", sep =""))
```

```
# second section
cam_func(path = "QC/", f = "01pos.mzML", mode = "pos")
cam_func(path = "QC/", f = "02neg.mzML", mode = "neg")
```

7. (optional, follow if followed 6.) add the QC files to your input files. This can be done simply by adding one more column to the input_table and adding the pos files against pos mode LCMS2 data and neg files against neg mode LCMS2 files. An example is given below:
               
```
for (i in 1:nrow(input_table)){
    if (grepl("pos", input_table[i, "mzml_files"], fixed=TRUE)){
        input_table[i, "qcCAM_csv"] <- "./QC/Combined_Camera_pos.csv"
    }
    if (grepl("neg", input_table[i, "mzml_files"], fixed=TRUE)){
        input_table[i, "qcCAM_csv"] <- "./QC/Combined_Camera_neg.csv"
    }
}
```
  
8. After the previous steps, we have all the inputs, their directories and optionally the QC csv files. Next is to initiate the workflow, (assuming we want to process only one LCMS2 .mzML file). Use the spec_Processing function to read and pre-process the MS2 spectra. The output is processed spectra and a list of precursor m/z(s) present in the .mzML file. Give the file path as an argument.
```
spec_pr <- spec_Processing(as.character(input_table[1, "mzml_files"]))
# Extract spectra
sps_all <- spec_pr[[1]]
# Extract precursor m/z
pre_mz<- spec_pr[[2]]
```
9. Using the above processed spectra, the workflow is ready to perform spectral database deprelication. In this workflow, "GNPS", "HMDB" and "MassBank" or all of these databases can be used. This function can be performed for all precursor m/z(s) in a loop. The function ```spec_dereplication``` takes one precursor m/z at a time, the result directory path, either from the input_table or as a whole written path e.g: "usr/s_cost/file_pos_01". The file_id is also taken from the input_table, as was generated by ms2_rfilename function, but is cutomizable as any other id given as a string e.g: "IDfile_pos_01". ppmx is ppm value used by the function to match the two spectra which have their m/z values atmost 15 ppm apart to be considered a match. This results in a directory called spectral_dereplication and contains results in csv files for each database.
```
for (i in pre_mz){
    df_derep <- spec_dereplication(i, db = "all", result_dir = input_table[1, "ResultFileNames"],
                file_id = input_table[1, "File_id"], input_dir, ppmx = 15)
}
```
10. In order to perform dereplication using compound databases, the Workflow uses SIRIUS and MetFrag. For these tools, we need MS2 fragmentation peak lists. The next function ```ms2_peaks``` extracts MS2 fragmentation spectra and stores the peaks for each precursor m/z in "/insilico/peakfiles_ms2/Peaks_01.txt". It takes the processed spectra from ```spec_Processing``` and result directory path.
```
spec_pr2 <- ms2_peaks(spec_pr, input_table[i, "ResultFileNames"])
```
11. For Formula identification in SIRIUS, a fragmentation tree generates tree score and isotopic peaks generate isotopic score, both of which form the sirius score. In order to utilize the isotopic score, isotopic peak annotation is required. For this purpose, the CAMERA results generated using CAMERA, are utilized here to extract the isotopic peaks for each precursor m/z and store them in "/insilico/peakfiles_ms2/Peaks_01.txt". The function ```ms1_peaks``` takes results from ms2_peaks, the associated QC csv file, the result directory and whether QC file is being used or not. If there is not QC csv file, enter NA and QC = FALSE.
```
ms1p <- ms1_peaks(spec_pr2, input_table[i, "qcCAM_csv"], input_table[i, "ResultFileNames"], QC = TRUE)
```
11. To create SIRIUS input files, use ```sirius_param``` function, which takes the output table from ```ms1_peaks``` and the result directory. If a suspect list is used, then SL = TRUE. 
```
sirius_param_files <- sirius_param(ms1p, result_dir = input_table[1, 'ResultFileNames'], SL = TRUE)
```
12. Run SIRIUS. Give the output of sirius_param as an argument to this fucntion, which contains a table of all the input and output paths for SIRIUS. Keep QC = TRUE, if QC files were used. If a suspect list is used, then SL = TRUE. Give path to the fragmentation tree directory. The suspect list fragmentation trees are calculated with a python defined function ```slist_SIRIUS``` and are stored in a directory named as ScostSLS/ within input directory. Candidates are the number of moleuclar formula considered for further SIRIUS calculations. If SL = FALSE, keep the SL_path = NA
```
run_sirius(files=sirius_param_files, ppm_max = 5, ppm_max_ms2 = 15, QC = TRUE, SL = TRUE, 
  SL_path = paste(input_dir, 'ScostSLS/', sep = ""), candidates = 30)
```
12. To run MetFrag, SIRIUS results are preprocessed to extract the best score Molecular formula and its adduct. The Adduct annotation is important to run Metfrag. In this function, give the result directoyr and whether a suspect list was used or not.
```
sirius_pproc <- sirius_postprocess(input_table[i, "ResultFileNames"], SL = TRUE)
```
12. Generate MetFrag parameter files. Give the sirius processed results as input. add the path of the MetFrag_AdductTypes.csv. Add path of the suspectlist InChIKeys generated by python function ```slist_metfrag``` for Metfrag.
```
met_param <- metfrag_param(sirius_pproc, result_dir = input_table[1, "ResultFileNames"],input_dir, 
  adducts = paste(input_dir, "MetFrag_AdductTypes.csv", sep = ""), 
  sl_mtfrag = paste(input_dir, "sl_metfrag.txt", sep = ""), SL = TRUE)
```
13. Run MetFrag.
```
for (files in met_param){
    system(paste("java -jar",  paste(input_dir, "MetFrag2.4.5-CL.jar", sep = ''), files))
}
```
